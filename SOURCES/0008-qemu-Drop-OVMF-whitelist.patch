From: Michal Privoznik <mprivozn@redhat.com>
Date: Wed, 19 Nov 2014 18:16:12 +0100
Subject: [PATCH] qemu: Drop OVMF whitelist

As discussed on the upstream list, it's better not to make this
kind of predictions in libvirt. It may happen that qemu learns
how to enable OVMF on other architectures too and we shouldn't
try to chase that.

Signed-off-by: Michal Privoznik <mprivozn@redhat.com>
(cherry picked from commit 36148120c1c1e6ad7f4eb6f0995eb7b18ba95922)
---
 src/qemu/qemu_capabilities.c |  9 +++------
 src/qemu/qemu_command.c      | 10 ----------
 2 files changed, 3 insertions(+), 16 deletions(-)

diff --git a/src/qemu/qemu_capabilities.c b/src/qemu/qemu_capabilities.c
index a48f668..3f69886 100644
--- a/src/qemu/qemu_capabilities.c
+++ b/src/qemu/qemu_capabilities.c
@@ -3627,7 +3627,6 @@ virQEMUCapsGetDefaultMachine(virQEMUCapsPtr qemuCaps)
 static int
 virQEMUCapsFillDomainLoaderCaps(virQEMUCapsPtr qemuCaps,
                                 virDomainCapsLoaderPtr capsLoader,
-                                virArch arch,
                                 char **loader,
                                 size_t nloader)
 {
@@ -3655,8 +3654,7 @@ virQEMUCapsFillDomainLoaderCaps(virQEMUCapsPtr qemuCaps,
     VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,
                              VIR_DOMAIN_LOADER_TYPE_ROM);
 
-    if (arch == VIR_ARCH_X86_64 &&
-        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DRIVE) &&
+    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DRIVE) &&
         virQEMUCapsGet(qemuCaps, QEMU_CAPS_DRIVE_FORMAT))
         VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,
                                  VIR_DOMAIN_LOADER_TYPE_PFLASH);
@@ -3673,14 +3671,13 @@ virQEMUCapsFillDomainLoaderCaps(virQEMUCapsPtr qemuCaps,
 static int
 virQEMUCapsFillDomainOSCaps(virQEMUCapsPtr qemuCaps,
                             virDomainCapsOSPtr os,
-                            virArch arch,
                             char **loader,
                             size_t nloader)
 {
     virDomainCapsLoaderPtr capsLoader = &os->loader;
 
     os->device.supported = true;
-    if (virQEMUCapsFillDomainLoaderCaps(qemuCaps, capsLoader, arch,
+    if (virQEMUCapsFillDomainLoaderCaps(qemuCaps, capsLoader,
                                         loader, nloader) < 0)
         return -1;
     return 0;
@@ -3776,7 +3773,7 @@ virQEMUCapsFillDomainCaps(virDomainCapsPtr domCaps,
 
     domCaps->maxvcpus = maxvcpus;
 
-    if (virQEMUCapsFillDomainOSCaps(qemuCaps, os, domCaps->arch,
+    if (virQEMUCapsFillDomainOSCaps(qemuCaps, os,
                                     loader, nloader) < 0 ||
         virQEMUCapsFillDomainDeviceDiskCaps(qemuCaps, disk) < 0 ||
         virQEMUCapsFillDomainDeviceHostdevCaps(qemuCaps, hostdev) < 0)
diff --git a/src/qemu/qemu_command.c b/src/qemu/qemu_command.c
index 163f80a..af95466 100644
--- a/src/qemu/qemu_command.c
+++ b/src/qemu/qemu_command.c
@@ -7680,16 +7680,6 @@ qemuBuildDomainLoaderCommandLine(virCommandPtr cmd,
         break;
 
     case VIR_DOMAIN_LOADER_TYPE_PFLASH:
-        /* UEFI is supported only for x86_64 currently */
-        if (def->os.arch != VIR_ARCH_X86_64 &&
-            def->os.arch != VIR_ARCH_ARMV7L &&
-            def->os.arch != VIR_ARCH_AARCH64) {
-            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,
-                           _("pflash is not supported for %s guest architecture"),
-                           virArchToString(def->os.arch));
-            goto cleanup;
-        }
-
         if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_DRIVE)) {
             virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
                            _("this QEMU binary doesn't support -drive"));
